(function() {
  'use strict';
  var EventEmitter, FSWatcher, fs, isBinary, nodeVersion, sysPath,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  EventEmitter = require('events').EventEmitter;

  fs = require('fs');

  sysPath = require('path');

  isBinary = require('./is-binary');

  nodeVersion = process.versions.node.substring(0, 3);

  exports.FSWatcher = FSWatcher = (function(superClass) {
    extend(FSWatcher, superClass);

    function FSWatcher(options1) {
      var base, base1, base2, base3, base4, base5;
      this.options = options1 != null ? options1 : {};
      this.close = bind(this.close, this);
      this.add = bind(this.add, this);
      this._handle = bind(this._handle, this);
      this._handleDir = bind(this._handleDir, this);
      this._handleFile = bind(this._handleFile, this);
      this._watch = bind(this._watch, this);
      this._remove = bind(this._remove, this);
      this._hasReadPermissions = bind(this._hasReadPermissions, this);
      this._removeFromWatchedDir = bind(this._removeFromWatchedDir, this);
      this._addToWatchedDir = bind(this._addToWatchedDir, this);
      this._getWatchedDir = bind(this._getWatchedDir, this);
      FSWatcher.__super__.constructor.apply(this, arguments);
      this.watched = Object.create(null);
      this.watchers = [];
      if ((base = this.options).persistent == null) {
        base.persistent = false;
      }
      if ((base1 = this.options).ignoreInitial == null) {
        base1.ignoreInitial = false;
      }
      if ((base2 = this.options).ignorePermissionErrors == null) {
        base2.ignorePermissionErrors = false;
      }
      if ((base3 = this.options).interval == null) {
        base3.interval = 100;
      }
      if ((base4 = this.options).binaryInterval == null) {
        base4.binaryInterval = 300;
      }
      if ((base5 = this.options).usePolling == null) {
        base5.usePolling = true;
      }
      this.enableBinaryInterval = this.options.binaryInterval !== this.options.interval;
      this._ignored = (function(_this) {
        return function(ignored) {
          switch (toString.call(ignored)) {
            case '[object RegExp]':
              return function(string) {
                return ignored.test(string);
              };
            case '[object Function]':
              return ignored;
            default:
              return function() {
                return false;
              };
          }
        };
      })(this)(this.options.ignored);
      Object.freeze(this.options);
    }

    FSWatcher.prototype._getWatchedDir = function(directory) {
      var base, dir;
      dir = directory.replace(/[\\\/]$/, '');
      return (base = this.watched)[dir] != null ? base[dir] : base[dir] = [];
    };

    FSWatcher.prototype._addToWatchedDir = function(directory, file) {
      var watchedFiles;
      watchedFiles = this._getWatchedDir(directory);
      return watchedFiles.push(file);
    };

    FSWatcher.prototype._removeFromWatchedDir = function(directory, file) {
      var watchedFiles;
      watchedFiles = this._getWatchedDir(directory);
      return watchedFiles.some((function(_this) {
        return function(watchedFile, index) {
          if (watchedFile === file) {
            watchedFiles.splice(index, 1);
            return true;
          }
        };
      })(this));
    };

    FSWatcher.prototype._hasReadPermissions = function(stats) {
      return Boolean(4 & parseInt((stats.mode & 0x1ff).toString(8)[0]));
    };

    FSWatcher.prototype._remove = function(directory, item) {
      var fullPath, nestedDirectoryChildren;
      fullPath = sysPath.join(directory, item);
      nestedDirectoryChildren = this._getWatchedDir(fullPath).slice();
      this._removeFromWatchedDir(directory, item);
      nestedDirectoryChildren.forEach((function(_this) {
        return function(nestedItem) {
          return _this._remove(fullPath, nestedItem);
        };
      })(this));
      fs.unwatchFile(fullPath);
      return this.emit('unlink', fullPath);
    };

    FSWatcher.prototype._watch = function(item, itemType, callback) {
      var basename, directory, options, parent, watcher;
      if (callback == null) {
        callback = (function() {});
      }
      directory = sysPath.dirname(item);
      basename = sysPath.basename(item);
      parent = this._getWatchedDir(directory);
      options = {
        persistent: this.options.persistent
      };
      if (parent.indexOf(basename) >= 0) {
        return;
      }
      this._addToWatchedDir(directory, basename);
      if (this.options.usePolling) {
        options.interval = this.enableBinaryInterval && isBinary(basename) ? this.options.binaryInterval : this.options.interval;
        return fs.watchFile(item, options, (function(_this) {
          return function(curr, prev) {
            if (curr.mtime.getTime() > prev.mtime.getTime()) {
              return callback(item, curr);
            }
          };
        })(this));
      } else {
        watcher = fs.watch(item, options, (function(_this) {
          return function(event, path) {
            return callback(item);
          };
        })(this));
        return this.watchers.push(watcher);
      }
    };

    FSWatcher.prototype._handleFile = function(file, stats, initialAdd) {
      if (initialAdd == null) {
        initialAdd = false;
      }
      this._watch(file, 'file', (function(_this) {
        return function(file, newStats) {
          return _this.emit('change', file, newStats);
        };
      })(this));
      if (!(initialAdd && this.options.ignoreInitial)) {
        return this.emit('add', file, stats);
      }
    };

    FSWatcher.prototype._handleDir = function(directory, initialAdd) {
      var read;
      read = (function(_this) {
        return function(directory, initialAdd) {
          return fs.readdir(directory, function(error, current) {
            var previous;
            if (error != null) {
              return _this.emit('error', error);
            }
            if (!current) {
              return;
            }
            previous = _this._getWatchedDir(directory);
            previous.filter(function(file) {
              return current.indexOf(file) === -1;
            }).forEach(function(file) {
              return _this._remove(directory, file);
            });
            return current.filter(function(file) {
              return previous.indexOf(file) === -1;
            }).forEach(function(file) {
              return _this._handle(sysPath.join(directory, file), initialAdd);
            });
          });
        };
      })(this);
      read(directory, initialAdd);
      return this._watch(directory, 'directory', function(dir) {
        return read(dir, false);
      });
    };

    FSWatcher.prototype._handle = function(item, initialAdd) {
      if (this._ignored(item)) {
        return;
      }
      return fs.realpath(item, (function(_this) {
        return function(error, path) {
          if (error && error.code === 'ENOENT') {
            return;
          }
          if (error != null) {
            return _this.emit('error', error);
          }
          return fs.stat(path, function(error, stats) {
            if (error != null) {
              return _this.emit('error', error);
            }
            if (_this.options.ignorePermissionErrors && (!_this._hasReadPermissions(stats))) {
              return;
            }
            if (stats.isFile()) {
              _this._handleFile(item, stats, initialAdd);
            }
            if (stats.isDirectory()) {
              return _this._handleDir(item, initialAdd);
            }
          });
        };
      })(this));
    };

    FSWatcher.prototype.emit = function() {
      var args, event;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      FSWatcher.__super__.emit.apply(this, arguments);
      if (event === 'add' || event === 'change' || event === 'unlink') {
        return FSWatcher.__super__.emit.apply(this, ['all', event].concat(slice.call(args)));
      }
    };

    FSWatcher.prototype.add = function(files) {
      if (!Array.isArray(files)) {
        files = [files];
      }
      files.forEach((function(_this) {
        return function(file) {
          return _this._handle(file, true);
        };
      })(this));
      return this;
    };

    FSWatcher.prototype.close = function() {
      this.watchers.forEach(function(watcher) {
        return watcher.close();
      });
      Object.keys(this.watched).forEach((function(_this) {
        return function(directory) {
          return _this.watched[directory].forEach(function(file) {
            return fs.unwatchFile(sysPath.join(directory, file));
          });
        };
      })(this));
      this.watched = Object.create(null);
      return this;
    };

    return FSWatcher;

  })(EventEmitter);

  exports.watch = function(files, options) {
    return new FSWatcher(options).add(files);
  };

}).call(this);
