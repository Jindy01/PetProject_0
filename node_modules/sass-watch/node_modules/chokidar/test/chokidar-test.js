(function() {
  var chokidar, delay, fixturesPath, fs, getFixturePath, isBinary, sysPath;

  chokidar = require('..');

  isBinary = require('../lib/is-binary');

  fs = require('fs');

  sysPath = require('path');

  getFixturePath = function(subPath) {
    return sysPath.join(__dirname, 'fixtures', subPath);
  };

  fixturesPath = getFixturePath('');

  delay = (function(_this) {
    return function(fn) {
      return setTimeout(fn, 205);
    };
  })(this);

  describe('chokidar', function() {
    it('should expose public API methods', function() {
      chokidar.FSWatcher.should.be.a('function');
      return chokidar.watch.should.be.a('function');
    });
    describe('watch', function() {
      var options;
      options = {};
      beforeEach(function(done) {
        this.watcher = chokidar.watch(fixturesPath, options);
        return delay((function(_this) {
          return function() {
            return done();
          };
        })(this));
      });
      afterEach(function(done) {
        this.watcher.close();
        delete this.watcher;
        return delay((function(_this) {
          return function() {
            return done();
          };
        })(this));
      });
      before(function() {
        try {
          fs.unlinkSync(getFixturePath('add.txt'), 'b');
        } catch (error) {}
        fs.writeFileSync(getFixturePath('change.txt'), 'b');
        fs.writeFileSync(getFixturePath('unlink.txt'), 'b');
        try {
          fs.unlinkSync(getFixturePath('subdir/add.txt'), 'b');
        } catch (error) {}
        try {
          return fs.rmdirSync(getFixturePath('subdir'), 'b');
        } catch (error) {}
      });
      after(function() {
        try {
          fs.unlinkSync(getFixturePath('add.txt'), 'a');
        } catch (error) {}
        fs.writeFileSync(getFixturePath('change.txt'), 'a');
        return fs.writeFileSync(getFixturePath('unlink.txt'), 'a');
      });
      it('should produce an instance of chokidar.FSWatcher', function() {
        return this.watcher.should.be.an["instanceof"](chokidar.FSWatcher);
      });
      it('should expose public API methods', function() {
        this.watcher.on.should.be.a('function');
        this.watcher.emit.should.be.a('function');
        this.watcher.add.should.be.a('function');
        return this.watcher.close.should.be.a('function');
      });
      it('should emit `add` event when file was added', function(done) {
        var spy, testPath;
        spy = sinon.spy();
        testPath = getFixturePath('add.txt');
        this.watcher.on('add', spy);
        return delay((function(_this) {
          return function() {
            spy.should.not.have.been.called;
            fs.writeFileSync(testPath, 'hello');
            return delay(function() {
              spy.should.have.been.calledOnce;
              spy.should.have.been.calledWith(testPath);
              return done();
            });
          };
        })(this));
      });
      it('should emit `change` event when file was changed', function(done) {
        var spy, testPath;
        spy = sinon.spy();
        testPath = getFixturePath('change.txt');
        this.watcher.on('change', spy);
        return delay((function(_this) {
          return function() {
            spy.should.not.have.been.called;
            fs.writeFileSync(testPath, 'c');
            return delay(function() {
              spy.should.have.been.calledOnce;
              spy.should.have.been.calledWith(testPath);
              return done();
            });
          };
        })(this));
      });
      it('should emit `unlink` event when file was removed', function(done) {
        var spy, testPath;
        spy = sinon.spy();
        testPath = getFixturePath('unlink.txt');
        this.watcher.on('unlink', spy);
        return delay((function(_this) {
          return function() {
            spy.should.not.have.been.called;
            fs.unlinkSync(testPath);
            return delay(function() {
              spy.should.have.been.calledOnce;
              spy.should.have.been.calledWith(testPath);
              return done();
            });
          };
        })(this));
      });
      it('should survive ENOENT for missing subdirectories', function() {
        var testDir;
        testDir = getFixturePath('subdir');
        return this.watcher.add(testDir);
      });
      return it('should notice when a file appears in a new directory', function(done) {
        var spy, testDir, testPath;
        spy = sinon.spy();
        testDir = getFixturePath('subdir');
        testPath = getFixturePath('subdir/add.txt');
        this.watcher.on('add', spy);
        this.watcher.add(testDir);
        return delay((function(_this) {
          return function() {
            spy.should.not.have.been.callled;
            fs.mkdirSync(testDir, 0x1ed);
            fs.writeFileSync(testPath, 'hello');
            return delay(function() {
              spy.should.have.been.calledOnce;
              spy.should.have.been.calledWith(testPath);
              return done();
            });
          };
        })(this));
      });
    });
    return describe('watch options', function() {
      return describe('ignoreInitial', function() {
        var options;
        options = {
          ignoreInitial: true
        };
        before(function(done) {
          try {
            fs.unlinkSync(getFixturePath('subdir/add.txt'));
          } catch (error) {}
          try {
            fs.rmdirSync(getFixturePath('subdir'));
          } catch (error) {}
          return done();
        });
        after(function(done) {
          try {
            fs.unlinkSync(getFixturePath('subdir/add.txt'));
          } catch (error) {}
          try {
            fs.rmdirSync(getFixturePath('subdir'));
          } catch (error) {}
          return done();
        });
        it('should ignore inital add events', function(done) {
          var spy, watcher;
          spy = sinon.spy();
          watcher = chokidar.watch(fixturesPath, options);
          watcher.on('add', spy);
          return delay(function() {
            spy.should.not.have.been.called;
            watcher.close();
            return done();
          });
        });
        return it('should notice when a file appears in an empty directory', function(done) {
          var spy, testDir, testPath, watcher;
          spy = sinon.spy();
          testDir = getFixturePath('subdir');
          testPath = getFixturePath('subdir/add.txt');
          watcher = chokidar.watch(fixturesPath, options);
          watcher.on('add', spy);
          return delay(function() {
            spy.should.not.have.been.called;
            fs.mkdirSync(testDir, 0x1ed);
            watcher.add(testDir);
            fs.writeFileSync(testPath, 'hello');
            return delay(function() {
              spy.should.have.been.calledOnce;
              spy.should.have.been.calledWith(testPath);
              return done();
            });
          });
        });
      });
    });
  });

  describe('is-binary', function() {
    it('should be a function', function() {
      return isBinary.should.be.a('function');
    });
    return it('should correctly determine binary files', function() {
      isBinary('a.jpg').should.equal(true);
      isBinary('a.jpeg').should.equal(true);
      isBinary('a.zip').should.equal(true);
      isBinary('ajpg').should.equal(false);
      return isBinary('a.txt').should.equal(false);
    });
  });

}).call(this);
